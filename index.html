<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Core Electric Outage Checker</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .container {
      width: 100%;
      max-width: 600px;
    }

    .card {
      background: white;
      border-radius: 16px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 30px;
      font-size: 2rem;
    }

    .search-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 30px;
    }

    .input-with-location {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .input-with-location input {
      flex: 1;
    }

    .location-btn {
      padding: 18px;
      font-size: 1.5rem;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
      min-width: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .location-btn:hover {
      background: #218838;
    }

    .location-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    input[type="text"] {
      padding: 18px;
      font-size: 1.1rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      transition: border-color 0.3s;
      width: 100%;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }

    button {
      padding: 18px 40px;
      font-size: 1.1rem;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.3s;
      font-weight: 600;
    }

    button:hover {
      background: #5568d3;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .result {
      text-align: center;
      padding: 40px;
      border-radius: 12px;
      animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .result-on {
      background: #d4edda;
      border: 3px solid #28a745;
    }

    .result-off {
      background: #f8d7da;
      border: 3px solid #dc3545;
    }

    .result-loading {
      background: #e7f3ff;
      border: 3px solid #667eea;
    }

    .result-icon {
      font-size: 4rem;
      margin-bottom: 20px;
    }

    .result-status {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 10px;
    }

    .result-on .result-status {
      color: #155724;
    }

    .result-off .result-status {
      color: #721c24;
    }

    .result-address {
      color: #6c757d;
      font-size: 0.95rem;
      margin-top: 10px;
    }

    .result-details {
      color: #6c757d;
      font-size: 1rem;
      margin-top: 10px;
    }

    .error {
      background: #fff3cd;
      border: 2px solid #ffc107;
      padding: 20px;
      border-radius: 12px;
      color: #856404;
      text-align: center;
    }

    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 2px solid #e0e0e0;
      border-top: none;
      border-radius: 0 0 12px 12px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .autocomplete-item {
      padding: 12px 18px;
      cursor: pointer;
      border-bottom: 1px solid #f0f0f0;
      transition: background 0.2s;
    }

    .autocomplete-item:hover {
      background: #f8f9fa;
    }

    .autocomplete-item:last-child {
      border-bottom: none;
    }

    .autocomplete-loading {
      padding: 12px 18px;
      color: #6c757d;
      text-align: center;
    }

    .autocomplete-distance {
      color: #667eea;
      font-size: 0.85rem;
      margin-left: 8px;
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.5rem;
      }

      .card {
        padding: 30px 20px;
      }

      .result-status {
        font-size: 1.5rem;
      }

      .result-icon {
        font-size: 3rem;
      }

      .input-with-location {
        flex-direction: row;
      }

      .location-btn {
        min-width: 50px;
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h1>‚ö° Core Electric Outage Checker</h1>

      <div class="search-section">
        <div class="input-with-location">
          <div class="autocomplete-container" style="flex: 1;">
            <input
              type="text"
              id="addressInput"
              placeholder="Enter your address"
              autocomplete="off"
            >
            <div id="autocompleteDropdown" style="display: none;"></div>
          </div>
          <button class="location-btn" id="locationBtn" onclick="useCurrentLocation()" title="Use current location">üìç</button>
        </div>
        <button id="searchBtn" onclick="searchAddress()">Check Power Status</button>
      </div>

      <div id="result"></div>
    </div>
  </div>

  <script>
    const API_URL = 'https://cache.sienatech.com/apex/siena_ords/webmaps/data/CORE/CUSTOMER';
    let outageData = null;
    let autocompleteTimeout = null;
    let selectedAddress = null;
    let userLocation = null;

    // Load outage data on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadData();

      const addressInput = document.getElementById('addressInput');

      // Allow Enter key to search
      addressInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          searchAddress();
        }
      });

      // Address autocomplete
      addressInput.addEventListener('input', (e) => {
        const query = e.target.value.trim();

        // Clear selected address when user types
        selectedAddress = null;

        if (query.length < 3) {
          hideAutocomplete();
          return;
        }

        // Debounce the autocomplete requests
        clearTimeout(autocompleteTimeout);
        autocompleteTimeout = setTimeout(() => {
          fetchAddressSuggestions(query);
        }, 300);
      });

      // Close autocomplete when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.autocomplete-container')) {
          hideAutocomplete();
        }
      });

      // Request location permission on load
      requestLocationPermission();
    });

    async function requestLocationPermission() {
      if (!navigator.geolocation) {
        console.warn('Geolocation not supported');
        return;
      }

      try {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            userLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };
            console.log('Location acquired:', userLocation);
          },
          (error) => {
            console.warn('Location permission denied or unavailable:', error.message);
          },
          { timeout: 5000 }
        );
      } catch (error) {
        console.warn('Location error:', error);
      }
    }

    async function useCurrentLocation() {
      const locationBtn = document.getElementById('locationBtn');

      if (!navigator.geolocation) {
        showError('Geolocation is not supported by your browser');
        return;
      }

      locationBtn.disabled = true;
      locationBtn.textContent = '‚è≥';

      try {
        navigator.geolocation.getCurrentPosition(
          async (position) => {
            userLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };

            // Reverse geocode to get address
            const reverseUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${userLocation.lat}&lon=${userLocation.lng}`;
            const response = await fetch(reverseUrl, {
              headers: {
                'User-Agent': 'CoreElectricOutageChecker/1.0'
              }
            });

            if (response.ok) {
              const data = await response.json();
              selectedAddress = {
                displayName: data.display_name,
                lat: userLocation.lat,
                lng: userLocation.lng
              };
              document.getElementById('addressInput').value = data.display_name;

              // Auto-search
              searchAddress();
            }

            locationBtn.disabled = false;
            locationBtn.textContent = 'üìç';
          },
          (error) => {
            showError('Could not get your location. Please check permissions.');
            console.error('Geolocation error:', error);
            locationBtn.disabled = false;
            locationBtn.textContent = 'üìç';
          },
          { enableHighAccuracy: true, timeout: 10000 }
        );
      } catch (error) {
        showError('Location access failed');
        console.error(error);
        locationBtn.disabled = false;
        locationBtn.textContent = 'üìç';
      }
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      // Haversine formula for distance in miles
      const R = 3959; // Earth's radius in miles
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    async function loadData() {
      try {
        const response = await fetch(API_URL);
        if (!response.ok) throw new Error('Failed to fetch data');
        outageData = await response.json();
      } catch (error) {
        console.error('Failed to load outage data:', error);
      }
    }

    async function fetchAddressSuggestions(query) {
      const dropdown = document.getElementById('autocompleteDropdown');

      dropdown.innerHTML = '<div class="autocomplete-loading">Searching...</div>';
      dropdown.style.display = 'block';

      try {
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=20&addressdetails=1&countrycodes=us`;
        const response = await fetch(url, {
          headers: {
            'User-Agent': 'CoreElectricOutageChecker/1.0'
          }
        });

        if (!response.ok) throw new Error('Search failed');

        const allResults = await response.json();

        // Filter to only Colorado addresses
        let results = allResults.filter(result => {
          const state = result.address?.state;
          return state === 'Colorado';
        });

        // If user location is available, sort by distance
        if (userLocation) {
          results = results.map(result => {
            const distance = calculateDistance(
              userLocation.lat,
              userLocation.lng,
              parseFloat(result.lat),
              parseFloat(result.lon)
            );
            return { ...result, distance };
          }).sort((a, b) => a.distance - b.distance);
        }

        results = results.slice(0, 5);

        if (results.length === 0) {
          dropdown.innerHTML = '<div class="autocomplete-loading">No Colorado addresses found</div>';
          return;
        }

        dropdown.innerHTML = results.map(result => {
          const distanceText = result.distance
            ? `<span class="autocomplete-distance">(${result.distance.toFixed(1)} mi)</span>`
            : '';
          return `
            <div class="autocomplete-item" onclick="selectAddress('${escapeHtml(result.display_name)}', ${result.lat}, ${result.lon})">
              ${escapeHtml(result.display_name)}${distanceText}
            </div>
          `;
        }).join('');

      } catch (error) {
        console.error('Autocomplete error:', error);
        hideAutocomplete();
      }
    }

    function selectAddress(displayName, lat, lng) {
      selectedAddress = {
        displayName: displayName,
        lat: parseFloat(lat),
        lng: parseFloat(lng)
      };

      document.getElementById('addressInput').value = displayName;
      hideAutocomplete();
    }

    function hideAutocomplete() {
      document.getElementById('autocompleteDropdown').style.display = 'none';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    async function searchAddress() {
      const addressInput = document.getElementById('addressInput');
      const address = addressInput.value.trim();

      if (!address) {
        showError('Please enter an address');
        return;
      }

      if (!outageData) {
        showError('Loading data... Please wait and try again.');
        return;
      }

      hideAutocomplete();

      // Show loading state
      document.getElementById('result').innerHTML = `
        <div class="result result-loading">
          <div class="result-icon">üîç</div>
          <div class="result-status">Searching...</div>
        </div>
      `;

      document.getElementById('searchBtn').disabled = true;

      try {
        let location;

        // If user selected an address from autocomplete, use that
        if (selectedAddress && selectedAddress.displayName === address) {
          location = selectedAddress;
        } else {
          // Otherwise geocode the address
          const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address + ', Colorado')}&limit=1`;
          const geocodeResponse = await fetch(geocodeUrl, {
            headers: {
              'User-Agent': 'CoreElectricOutageChecker/1.0'
            }
          });

          if (!geocodeResponse.ok) throw new Error('Geocoding failed');

          const geocodeData = await geocodeResponse.json();

          if (!geocodeData || geocodeData.length === 0) {
            showError('Address not found. Please try a different address.');
            document.getElementById('searchBtn').disabled = false;
            return;
          }

          location = {
            lat: parseFloat(geocodeData[0].lat),
            lng: parseFloat(geocodeData[0].lon),
            displayName: geocodeData[0].display_name
          };
        }

        // Get zip code for this location
        const zipCode = await findZipCodeForLocation(location);

        if (!zipCode) {
          showError('Could not determine zip code for this address.');
          document.getElementById('searchBtn').disabled = false;
          return;
        }

        // Check outage status
        const zipReport = outageData.reportData.reports.find(r => r.id === 'Zip');
        if (!zipReport) {
          showError('Unable to check outage status.');
          document.getElementById('searchBtn').disabled = false;
          return;
        }

        const area = zipReport.polygons.find(p => p.name === zipCode);

        if (!area) {
          showError(`This address (${zipCode}) is not in Core Electric service area.`);
          document.getElementById('searchBtn').disabled = false;
          return;
        }

        // Display result
        const isOut = area.affected > 0;
        displayResult(isOut, location.displayName, area);

        document.getElementById('searchBtn').disabled = false;

      } catch (error) {
        showError('Failed to check address. Please try again.');
        console.error(error);
        document.getElementById('searchBtn').disabled = false;
      }
    }

    async function findZipCodeForLocation(location) {
      try {
        const reverseUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${location.lat}&lon=${location.lng}`;
        const response = await fetch(reverseUrl, {
          headers: {
            'User-Agent': 'CoreElectricOutageChecker/1.0'
          }
        });

        if (response.ok) {
          const data = await response.json();
          if (data.address && data.address.postcode) {
            return data.address.postcode.split('-')[0];
          }
        }
      } catch (e) {
        console.warn('Reverse geocoding failed:', e);
      }
      return null;
    }

    function displayResult(isOut, addressName, area) {
      const resultClass = isOut ? 'result-off' : 'result-on';
      const icon = isOut ? 'üî¥' : '‚úÖ';
      const status = isOut ? 'POWER OFF' : 'POWER ON';
      const detailsText = isOut
        ? `${area.affected.toLocaleString()} customers affected in ${area.name}`
        : `No outages in ${area.name}`;

      document.getElementById('result').innerHTML = `
        <div class="result ${resultClass}">
          <div class="result-icon">${icon}</div>
          <div class="result-status">${status}</div>
          <div class="result-details">${detailsText}</div>
          <div class="result-address">üìç ${addressName}</div>
        </div>
      `;
    }

    function showError(message) {
      document.getElementById('result').innerHTML = `
        <div class="error">‚ö†Ô∏è ${message}</div>
      `;
    }
  </script>
</body>
</html>
