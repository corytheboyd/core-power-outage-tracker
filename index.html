<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polyline Renderer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            width: 100%;
            height: 100vh;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 250px;
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .info-panel p {
            margin: 5px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
<div id="map"></div>
<div class="info-panel">
    <h3>Polyline Data</h3>
    <p><strong>Total Lines:</strong> <span id="lineCount">0</span></p>
    <p><strong>Total Points:</strong> <span id="pointCount">0</span></p>
    <p><strong>Error Points:</strong> <span id="errorCount">0</span></p>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    // Polyline decoding function
    function decodePolyline(encoded) {
        const coordinates = [];
        let index = 0;
        let lat = 0;
        let lng = 0;

        while (index < encoded.length) {
            // Decode latitude
            let shift = 0;
            let result = 0;
            let byte;

            do {
                byte = encoded.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);

            const deltaLat = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lat += deltaLat;

            // Decode longitude
            shift = 0;
            result = 0;

            do {
                byte = encoded.charCodeAt(index++) - 63;
                result |= (byte & 0x1f) << shift;
                shift += 5;
            } while (byte >= 0x20);

            const deltaLng = ((result & 1) ? ~(result >> 1) : (result >> 1));
            lng += deltaLng;

            coordinates.push([lat / 1e5, lng / 1e5]);
        }

        return coordinates;
    }

    // Your data
    const data = {"lines":[{"g":"aidqFbewbSmkBpnA","f":"AC8C973707098531F73BA92BF9440008","e":0,"t":"t"},{"g":"{~jpFblfaSYnQ","f":"15072E169E04098BB063ECDFF3181E7E","e":0,"t":"t"},{"g":"oblpFnckaS|D}T","f":"A179530456B0FFB127582E97622D03FA","e":0,"t":"t"},{"g":"euvoFdhabS_JbH","f":"6B52FD3B939B2F1E88B0F50D644391A4","e":0,"t":"t"},{"g":"qcjoFlqraSrYa@","f":"903DEE2F740AFDCE315BBF9D1A0AF5F7","e":0,"t":"t"},{"g":"wf|oFrfyaSx[ckA","f":"F1EF4A60F10E5F62756C43922BE6A9C1","e":0,"t":"t"},{"g":"ka|oFbnpaS~MeG","f":"D47044C6E3AF9BFAB25F00AEAA15ED4B","e":0,"t":"t"},{"g":"}|toFfrlbSvCeO","f":"22D94AAA6498E5C5669ADCAD9F004A2B","e":0,"t":"t"},{"g":"}kqoFdtpbSqFkZ","f":"133CB6BC9B120D19BA275A99FDAEB861","e":0,"t":"t"},{"g":"qbroFtupbS`MkW{Itb@","f":"BCE9A84A4187D0ABD0BEA9B6288E2806","e":0,"t":"t"}]};

    // Initialize map
    const map = L.map('map');

    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors',
        maxZoom: 19
    }).addTo(map);

    let allCoordinates = [];
    let totalPoints = 0;
    let errorPoints = 0;

    // Process each polyline
    data.lines.forEach((line, index) => {
        try {
            const coords = decodePolyline(line.g);

            if (coords.length > 0) {
                totalPoints += coords.length;

                // Different colors for error points
                const color = line.e === 2 ? '#ff0000' : '#0066ff';
                if (line.e === 2) errorPoints++;

                // Add polyline to map
                L.polyline(coords, {
                    color: color,
                    weight: 3,
                    opacity: 0.7
                }).addTo(map).bindPopup(`
                        <b>Line ${index + 1}</b><br>
                        Points: ${coords.length}<br>
                        Error: ${line.e}<br>
                        Hash: ${line.f.substring(0, 8)}...
                    `);

                // Collect all coordinates for bounds
                allCoordinates = allCoordinates.concat(coords);
            }
        } catch (err) {
            console.error(`Error decoding line ${index}:`, err);
        }
    });

    // Update info panel
    document.getElementById('lineCount').textContent = data.lines.length;
    document.getElementById('pointCount').textContent = totalPoints;
    document.getElementById('errorCount').textContent = errorPoints;

    // Fit map to show all polylines
    if (allCoordinates.length > 0) {
        const bounds = L.latLngBounds(allCoordinates);
        map.fitBounds(bounds, { padding: [50, 50] });
    }
</script>
</body>
</html>